# Основное

Приложение представляет собой бэкенд http веб сервиса для ведения списка дел.
Реализовано на языке java на фреймворке spring boot с системой сборки gradle.
Для запуска нужна java и локальный постгрес(настройки подключения нужно 
указать в файле [application.yml](./application.yml))

# Выполненные требования

## 1

### Приложение поддерживает аутентификацию пользователей и контроль доступа к API (0.66 балла)

Поддерживается регистрация через электронную почту(но нужно иметь почту с 
2-факторной аутентификацией и сгенерированным паролем для приложений) и 
через лог(в лог пишется id, который нужно прислать в специальную ручку для 
подтверждения).
Аутентификация реализована через spring-security и работает с помощью 
внутренних механизмов спринга(при логине в cookie 
`JSESSIONID` проставляется id авторизованной сессии и пользователь какое-то 
время с этим cookie может пользоваться api без ограничений).
Зарегистрированные пользователи хранятся в бд с шифрованием пролей с помощью 
bcrypt. Сессии аутентификации хранятся в рантайме(так что если перезапустить 
приложение, то аутентификацию слетит). 
Полный путь получения доступа: инициировать регистрацию(один из двух методов),
получить ключ(или сообщение по почте) и использовать его в подтверждении 
регистрации, далее вызвать ручку логина с указанными при регистрации данными 
и у вас есть доступ к API

### Приложение имеет gRPC или HTTP API (минимум четыре бизнес-метода: создание, получение, изменение, удаление) (0.66 балла)

...

### Все сервисы и API покрыты тестами (unit и функциональными) (0.66 балла)

...

### Приложение использует внешнюю БД для хранения пользователей и бизнес информации (0.66 балла)

Для хранения данных используем внешнюю бд postgresql. 
Из интересного: для обновления колонки `last_modified_at` используем триггер 
на уровне бд(то есть даже меняя руками бд это время поменяется)

### Схема базы данных создаётся при запуске или деплое приложения, поддерживается версионирование схемы (0.66 балла)

Схема создается и обновляется не при запуске или деплое, но при сборке. Так 
сделано, потому что следующий пункт это генерация таблиц в коде по бд. 
Генерация работает до запуска, поэтому все миграции необходимо запускать 
перед сборкой. Для версионирования используется liquibase с кодом на sql(так 
как все остальные варианты не нативные и не такие гибкие как sql)

### Схема базы данных отражается в код при сборке. Несоответствие ORM-моделей, запросов и схемы приводит к ошибке сборки (0.66 балла)

Используется подход database first, то есть по базе данных генерируются 
таблицы. Для генерации используется фреймворк Jooq. Его настройка далась 
очень тяжело, так как он предназначен для maven, а для gradle очень мало 
инструкций, пришлось разбираться методом тыка. Большая часть build.gradle 
состоит из настройки Jooq







